// ==UserScript==
// @name         OnlineDice Color Hack GUI (3 dice)
// @namespace    http://tampermonkey.net/
// @version      1.0
// @description  Th√™m GUI ch·ªçn m√†u cho 3 dice (visual only). M√†u ch·ªâ thay ƒë·ªïi sau user b·∫•m ROLL v√† sau khi animation k·∫øt th√∫c.
// @author       imdev-helper
// @match        https://www.online-dice.com/roll-color-dice/3/*
// @grant        none
// @run-at       document-idle
// ==/UserScript==

(function () {
  'use strict';

  /* =========================
     C·∫•u h√¨nh & helper
     ========================= */
  const STORAGE_KEY = 'od_colorhack_v1';
  const DEBOUNCE_AFTER_MUTATION_MS = 600; // sau khi DOM kh√¥ng thay ƒë·ªïi trong kho·∫£ng n√†y => coi nh∆∞ animation k·∫øt th√∫c

  // default colors
  const DEFAULTS = {
    colors: ['#f4a300', '#f4a300', '#6b1fa8'], // gi·ªëng screenshot (2 v√†ng 1 t√≠m)
    autoApplyAfterRoll: false
  };

  function loadSettings() {
    try {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) return JSON.parse(JSON.stringify(DEFAULTS));
      return Object.assign({}, DEFAULTS, JSON.parse(raw));
    } catch (e) {
      console.error('Load settings error', e);
      return JSON.parse(JSON.stringify(DEFAULTS));
    }
  }
  function saveSettings(obj) {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(obj));
  }

  let settings = loadSettings();

  /* =========================
     UI: floating panel (nice)
     ========================= */
  function createUI() {
    const wrap = document.createElement('div');
    wrap.id = 'od-colorhack-wrap';
    wrap.innerHTML = `
      <div class="od-card">
        <div class="od-header">
          <div class="od-title">Dice Visual Colorizer</div>
          <button class="od-close" title="·∫®n">‚úï</button>
        </div>
        <div class="od-body">
          <div class="od-row"><label>Dice 1</label><input class="od-color" data-idx="0" type="color"></div>
          <div class="od-row"><label>Dice 2</label><input class="od-color" data-idx="1" type="color"></div>
          <div class="od-row"><label>Dice 3</label><input class="od-color" data-idx="2" type="color"></div>
          <div class="od-row od-row-actions">
            <button class="od-btn od-btn-primary" id="od-save">Save</button>
            <button class="od-btn" id="od-apply-now">Apply Now (visual)</button>
          </div>
          <label class="od-toggle"><input type="checkbox" id="od-autoapply"> Auto apply after each Roll</label>
          <div class="od-note">L∆∞u √Ω: m√†u s·∫Ω th·ª±c s·ª± thay ƒë·ªïi sau khi b·∫°n <b>b·∫•m ROLL</b> v√† animation k·∫øt th√∫c.</div>
        </div>
      </div>
      <button id="od-floating-toggle" title="Open Colorizer">üé®</button>
    `;

    const css = `
    #od-colorhack-wrap { position: fixed; right: 18px; bottom: 18px; z-index: 999999; font-family: Inter, Arial, sans-serif; }
    #od-floating-toggle { position: fixed; right: 18px; bottom: 18px; z-index: 999999; width:56px; height:56px; border-radius:50%; border:none; box-shadow:0 6px 20px rgba(0,0,0,.25); font-size:24px; background:linear-gradient(180deg,#ffffff,#e6f2ff); cursor:pointer; }
    #od-colorhack-wrap .od-card { width:320px; max-width:calc(100vw - 40px); background: linear-gradient(180deg,#ffffff,#f7fbff); border-radius:12px; box-shadow:0 10px 30px rgba(40,60,80,.18); padding:12px; display:none; }
    #od-colorhack-wrap .od-header { display:flex; justify-content:space-between; align-items:center; margin-bottom:8px; }
    #od-colorhack-wrap .od-title { font-weight:700; font-size:14px; color:#0b4d92; }
    #od-colorhack-wrap .od-close { border: none; background: transparent; cursor: pointer; font-size:14px; }
    #od-colorhack-wrap .od-body { padding-top:4px; }
    #od-colorhack-wrap .od-row { display:flex; justify-content:space-between; align-items:center; gap:8px; margin:8px 0; }
    #od-colorhack-wrap .od-row label { font-size:13px; color:#234; }
    #od-colorhack-wrap .od-color { width:70px; height:34px; border-radius:6px; border:1px solid #cdd; padding:3px; background:white; cursor:pointer; }
    #od-colorhack-wrap .od-btn { padding:8px 10px; border-radius:8px; border:1px solid #c8d8ef; background:#f6faff; cursor:pointer; }
    #od-colorhack-wrap .od-btn-primary { background: linear-gradient(180deg,#2f8ffd,#2677e0); color:white; border: none; }
    #od-colorhack-wrap .od-toggle { display:block; margin-top:8px; font-size:13px; color:#234; }
    #od-colorhack-wrap .od-note { font-size:12px; color:#556; margin-top:8px; }
    `;

    const style = document.createElement('style');
    style.textContent = css;
    document.head.appendChild(style);
    document.body.appendChild(wrap);

    const card = wrap.querySelector('.od-card');
    const toggle = wrap.querySelector('#od-floating-toggle');
    const close = wrap.querySelector('.od-close');

    // init inputs
    const colorInputs = wrap.querySelectorAll('.od-color');
    colorInputs.forEach(inp => {
      const idx = Number(inp.dataset.idx);
      inp.value = settings.colors[idx] || DEFAULTS.colors[idx] || '#ffffff';
      inp.addEventListener('input', (e) => {
        settings.colors[idx] = e.target.value;
      });
    });

    // auto apply checkbox
    const autoEl = wrap.querySelector('#od-autoapply');
    autoEl.checked = !!settings.autoApplyAfterRoll;
    autoEl.addEventListener('change', (e) => {
      settings.autoApplyAfterRoll = !!e.target.checked;
      saveSettings(settings);
    });

    // Save button
    wrap.querySelector('#od-save').addEventListener('click', () => {
      // ensure inputs updated
      colorInputs.forEach(inp => {
        const idx = Number(inp.dataset.idx);
        settings.colors[idx] = inp.value;
      });
      saveSettings(settings);
      alert('Saved colors');
    });

    // Apply now (visual change immediately)
    wrap.querySelector('#od-apply-now').addEventListener('click', () => {
      colorInputs.forEach(inp => {
        const idx = Number(inp.dataset.idx);
        settings.colors[idx] = inp.value;
      });
      saveSettings(settings);
      applyColorsToDiceIfExists(settings.colors);
    });

    // Toggle open/close
    toggle.addEventListener('click', () => {
      if (card.style.display === 'block') {
        card.style.display = 'none';
      } else {
        card.style.display = 'block';
      }
    });
    close.addEventListener('click', () => card.style.display = 'none');

    return { wrap, colorInputs, toggle, card };
  }

  /* =========================
     Dice detection & apply color logic
     ========================= */

  // T√¨m c√°c element dice - chi·∫øn l∆∞·ª£c:
  // 1) T√¨m container trung t√¢m ch·ª©a "ROLL COLOR DICE" (theo text).
  // 2) Trong container ƒë√≥, ch·ªçn nh·ªØng div hi·ªÉn th·ªã c√≥ k√≠ch th∆∞·ªõc vu√¥ng/near-square l·ªõn (>=40px).
  // 3) Tr·∫£ v·ªÅ 3 element top-most (theo v·ªã tr√≠ ngang).
  function findDiceElements() {
    // try to find by text header 'ROLL COLOR DICE'
    const header = Array.from(document.querySelectorAll('h1,h2,h3,div,span')).find(el => {
      if (!el || !el.textContent) return false;
      return /ROLL\s*COLOR\s*DICE/i.test(el.textContent.trim());
    });
    let container = null;
    if (header) {
      // ƒëi l√™n v√†i c·∫•p ƒë·ªÉ t√¨m ph·∫ßn ch√≠nh gi·ªØa
      container = header.closest('section,div') || header.parentElement;
    }
    if (!container) {
      // fallback: choose main element center of viewport
      container = document.querySelector('main') || document.body;
    }

    // collect candidate elements (descendants)
    const candidates = Array.from(container.querySelectorAll('div,span'));
    const visibleSquares = candidates.filter(el => {
      try {
        const rect = el.getBoundingClientRect();
        if (!rect || rect.width < 40 || rect.height < 40) return false; // must be visible & reasonable size
        // roughly square
        const ratio = rect.width / rect.height;
        if (ratio < 0.75 || ratio > 1.45) return false;
        // must be on visible area (not off-screen)
        if (rect.bottom < 0 || rect.top > window.innerHeight + 100) return false;
        // not tiny text nodes
        if (el.children.length > 6) return false; // avoid large containers
        // pass
        return true;
      } catch (e) {
        return false;
      }
    });

    // sort by x position (left to right)
    visibleSquares.sort((a, b) => a.getBoundingClientRect().left - b.getBoundingClientRect().left);

    // choose first 3 distinct elements
    const dice = visibleSquares.slice(0, 3);
    return dice.length === 3 ? dice : null;
  }

  function applyColorsToDiceIfExists(colors) {
    const dice = findDiceElements();
    if (!dice || dice.length !== 3) {
      console.warn('OD ColorHack: kh√¥ng t√¨m th·∫•y 3 dice r√µ r√†ng ƒë·ªÉ apply m√†u hi·ªán t·∫°i.');
      return false;
    }

    // apply CSS carefully: change background and dot color if possible.
    dice.forEach((el, idx) => {
      try {
        // store original styles for possible later undo
        if (!el.dataset.od_orig_bg) {
          el.dataset.od_orig_bg = el.style.background || window.getComputedStyle(el).backgroundColor || '';
        }
        // set background color and slight shadow/border so it looks natural
        el.style.background = colors[idx] || colors[0] || '#fff';
        el.style.transition = 'background 300ms ease, box-shadow 300ms ease, transform 200ms';
        el.style.boxShadow = '0 6px 14px rgba(0,0,0,0.16)';
        el.style.borderRadius = '10px';

        // try to find inner dot (the pip) and set it to white or contrasting color
        const inner = el.querySelector('div, span, i') || null;
        if (inner) {
          inner.style.background = '#fff';
          inner.style.color = '#fff';
        }
      } catch (e) {
        console.warn('Apply color error', e);
      }
    });
    return true;
  }

  /* =========================
     Roll detection & mutation handling
     ========================= */

  let pendingApply = false;
  let pendingColors = null;
  let mutationTimer = null;
  let observer = null;

  function onUserClickedRoll(colorsToApply) {
    // called when user clicks a button containing 'ROLL' text
    pendingApply = true;
    pendingColors = Array.isArray(colorsToApply) ? colorsToApply.slice() : (settings.colors.slice());
    // start observing mutations in the document/body to detect animation changes
    startObservingMutations();
  }

  function startObservingMutations() {
    if (observer) return;
    observer = new MutationObserver((mutations) => {
      // when any mutation appears, reset debounce timer
      if (mutationTimer) clearTimeout(mutationTimer);
      mutationTimer = setTimeout(() => {
        // considered "stable" now (animation likely finished)
        onMutationsStable();
      }, DEBOUNCE_AFTER_MUTATION_MS);
    });
    observer.observe(document.body, { childList: true, subtree: true, attributes: true, characterData: false });
    // also set a fallback max time (in case no mutations fire): 2.5s
    if (mutationTimer) clearTimeout(mutationTimer);
    mutationTimer = setTimeout(() => onMutationsStable(), 2500);
  }

  function stopObservingMutations() {
    if (observer) {
      try { observer.disconnect(); } catch (e) {}
      observer = null;
    }
    if (mutationTimer) {
      clearTimeout(mutationTimer);
      mutationTimer = null;
    }
  }

  function onMutationsStable() {
    if (!pendingApply) {
      stopObservingMutations();
      return;
    }
    // apply colors now
    const ok = applyColorsToDiceIfExists(pendingColors || settings.colors);
    if (!ok) {
      // if can't find dice, keep observing a bit more (maybe page updates)
      if (mutationTimer) clearTimeout(mutationTimer);
      mutationTimer = setTimeout(() => {
        // final attempt
        applyColorsToDiceIfExists(pendingColors || settings.colors);
        pendingApply = false;
        pendingColors = null;
        stopObservingMutations();
      }, 800);
      return;
    }
    // done
    pendingApply = false;
    pendingColors = null;
    stopObservingMutations();
    console.debug('OD ColorHack: colors applied after roll.');
  }

  /* =========================
     Detect Roll button clicks
     ========================= */

  function registerRollClickListener() {
    // capture clicks on buttons/links that contain 'ROLL' text
    document.addEventListener('click', (e) => {
      try {
        let tgt = e.target;
        // climb until button or link or element with text
        for (let i = 0; i < 6 && tgt; i++, tgt = tgt.parentElement) {
          if (!tgt) break;
          if (tgt.tagName && /BUTTON|A|DIV|SPAN|INPUT/i.test(tgt.tagName)) {
            const txt = (tgt.textContent || tgt.value || '').trim();
            if (/^\s*roll\b/i.test(txt) || /\broll\b/i.test(txt)) {
              // user clicked a roll-like button
              // only trigger if they are genuine user clicks (not script-invoked). e.isTrusted helps
              if (!e.isTrusted) return;
              // schedule apply after animation complete
              console.debug('OD ColorHack: detected ROLL click on element:', tgt);
              if (settings.autoApplyAfterRoll) {
                onUserClickedRoll(settings.colors);
              } else {
                // if not auto apply, still respect requirement: only change if user used ROLL AGAIN
                // we'll still prepare pendingApply so script will apply once user clicks ROLL and we call apply.
                // But for manual mode we want to apply only when user explicitly requests: so do nothing here.
                // However user explicitly asked colors only changed when they press ROLL AGAIN; to support that,
                // we will still mark pendingApply true so any next stable mutation will apply (consistent).
                onUserClickedRoll(settings.colors);
              }
              return;
            }
          }
        }
      } catch (e) {
        console.error(e);
      }
    }, true); // use capture so we see clicks earlier
  }

  /* =========================
     Init
     ========================= */

  function init() {
    const ui = createUI();
    // make sure saved colors reflected in UI inputs
    ui.colorInputs.forEach(inp => {
      const idx = Number(inp.dataset.idx);
      inp.value = settings.colors[idx] || DEFAULTS.colors[idx] || '#ffffff';
    });
    // start listening clicks
    registerRollClickListener();

    // also: try to apply saved colors to current dice on load if user wants (visual only)
    // but we will not auto-change unless user clicked ROLL; still provide immediate preview when pressing "Apply Now".
    console.debug('OD ColorHack initialized: settings', settings);
  }

  // run
  init();

  /* =========================
     Expose API to console for debugging
     ========================= */
  window.OD_COLORHACK = {
    settings,
    applyColors: applyColorsToDiceIfExists,
    findDiceElements
  };

})();
